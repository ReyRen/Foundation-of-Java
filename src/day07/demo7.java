package day07;

/**
 * Created by reyren on 2016/11/4.
 */

/*
* static：
*   1.static修饰成员变量：如果有数据需要被共享给所有对象使用时，就可以使用static修饰
*       静态成员变量的访问方式：
*           1.可以使用对象进行访问 对象.静态变量名
*           2.也可以使用类名进行访问 类名.变量名
*       注意：
*           1.非静态的成员变量只能使用对象进行访问，不能使用类名进行f访问
*           2.千万不要为了方便访问数据而使用static修饰成员变量，只有成员变量是真正需要被共享的数据才使用static修饰
*       应用场景：如果一个数据需要被所有对象共享使用的时候，即可使用static修饰
*
*   2.stati修饰成员函数：
*       访问方式：
*           1.可以使用对象进行访问  对象.静态函数名
*           2.也可以用类名进行访问
*推荐使用类名访问静态的成员
*   节省内存，不用浪费对象所占用的空间
*注意事项：
*   静态的函数可以直接访问静态的成员，但是不能直接访问非静态的成员（成员变量和成员函数）
*           静态的函数是可以使用类名直接调用的，这时候可能还没有存在对象，而非静态的成员数据是随着对象的存在而存在的
*   非静态函数是可以访问静态与非静态的成员（非静态函数只能由对象调用，当对象存在的时候，静态数据老早就存在了，而非静态数据也随着对象的创建儿存在了）
*   静态函数不能出现this或者super关键字（不能用this是因为可能用类名调用，是没有对象的）
*静态数据的生命周期：
*   静态的成员变量数据是优先于对象存在的，静态和非静态方法是同时出现在内存中的
*
*什么时候static修饰一个函数：
*   如果一个函数没有直接访问到非静态的成员时，那么就可以使用static修饰了,一般用于工具类的方法
*静态函数只要存在有对象，那么也可以访问非静态的数据，只是不能直接访问
* */

/*需求：统计一个类被使用了多少次创建爱对象，该类对外显示被创建的次数
* */
public class demo7 {

    public static void main(String[] args) {
        Emp e1 = new Emp();
        Emp e2 = new Emp();
        Emp e3 = new Emp();
        Emp e4 = new Emp();
        e4.showCount();
    }
}
class Emp{

    //int count = 0;//这是非静态，所以在每次创建对象的时候都是从0开始加，因为每个对象都有一份的，以至于下面结果是1
    static int count = 0;
    /*public Emp(){//每创建一个对象的时候都会执行构造函数
        count++;
    }*/

    static{//静态代码块是在，class文件加载到内存中的时候马上执行了
        System.out.println("静态代码块执行了");
    }

    {
        count++;//因为这样可以避免有其他有参数的构造方法也要count++
    }
    public void showCount(){
        System.out.println("创建了"+ count + "个对象");
    }
}